var imglyBackgroundRemoval = function (e) { "use strict"; var t = {}; function n(r) { if (t[r]) return t[r].exports; var o = t[r] = { i: r, l: !1, exports: {} }; return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports } return n.m = e, n.c = t, n.d = function (e, t, r) { n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r }) }, n.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.t = function (e, t) { if (1 & t && (e = n(e)), 8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var r = Object.create(null); if (n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var o in e) n.d(r, o, function (t) { return e[t] }.bind(null, o)); return r }, n.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return n.d(t, "a", t), t }, n.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, n.p = "", n(n.s = 0) }([function (e, t, n) { n.r(t), n.d(t, "removeBackground", (function () { return f })); let r = null; const o = async (e, t = null) => { if (r) return r; const n = t && t.publicPath ? t.publicPath.replace(/\/$/, "") + "/" : "https://static.img.ly/background-removal-data/1.0.3/"; let o = n; return t && t.debug, r = await new Promise((e, t) => { const r = window.URL || window.webkitURL, a = new Blob(["importScripts('" + o + "dist/ort-wasm-simd.min.js'); self.onmessage = async (e) => { const { type, data } = e.data; if (type === 'init') { try { const session = await ort.InferenceSession.create(data.model, { executionProviders: ['wasm'], graphOptimizationLevel: 'all' }); self.postMessage({ type: 'init_success', session }); } catch (err) { self.postMessage({ type: 'error', error: err }); } } else if (type === 'run') { try { const { input, config } = data; const feeds = {}; feeds[config.inputName] = new ort.Tensor('float32', input.data, input.dims); const results = await self.session.run(feeds); const output = results[config.outputName]; self.postMessage({ type: 'success', output: { data: output.data, dims: output.dims } }, [output.data.buffer]); } catch (err) { self.postMessage({ type: 'error', error: err }); } } }"], { type: "application/javascript" }), i = new Worker(r.createObjectURL(a)); e(i) }), r }, a = async (e, t) => { const n = new Image; return n.src = e, new Promise(e => { n.onload = () => { const r = document.createElement("canvas"); r.width = n.width, r.height = n.height; const o = r.getContext("2d"); o.drawImage(n, 0, 0); const a = o.getImageData(0, 0, n.width, n.height); e(a) } }) }, i = async (e, t) => { const n = document.createElement("canvas"); n.width = e.width, n.height = e.height; const r = n.getContext("2d"), o = r.createImageData(e.width, e.height); return o.data.set(e.data), r.putImageData(o, 0, 0), new Promise(e => { n.toBlob(e, t) }) }, c = async e => { const t = await fetch(e); return await t.arrayBuffer() }, u = async (e, t) => { const n = t.publicPath ? t.publicPath.replace(/\/$/, "") + "/" : "https://static.img.ly/background-removal-data/1.0.3/"; let r = n + "isnet_fp16.onnx"; t.model_url && (r = t.model_url); const o = await c(r), a = await c(n + "isnet_fp16.quint8.onnx"); return { original: o, quantized: a } }, s = async (e, t, n) => { const r = t.width, o = t.height, a = n.width, i = n.height, c = new Float32Array(3 * a * i), u = r / a, s = o / i; for (let n = 0; n < i; n++)for (let l = 0; l < a; l++) { const f = Math.floor(l * u), d = Math.floor(n * s), g = 4 * (d * r + f); c[n * a + l] = (t.data[g] - e[0]) / e[3], c[a * i + n * a + l] = (t.data[g + 1] - e[1]) / e[4], c[2 * a * i + n * a + l] = (t.data[g + 2] - e[2]) / e[5] } return c }, l = async (e, t, n) => { const r = t.width, o = t.height, a = n.width, i = n.height, c = new Uint8ClampedArray(4 * r * o), u = r / a, s = o / i; for (let n = 0; n < o; n++)for (let l = 0; l < r; l++) { const f = Math.floor(l / u), d = Math.floor(n / s), g = 4 * (n * r + l), h = e[d * a + f]; c[g] = t.data[g], c[g + 1] = t.data[g + 1], c[g + 2] = t.data[g + 2], c[g + 3] = 255 * h } return new ImageData(c, r, o) }, f = async (e, t = {}) => { const n = t.publicPath ? t.publicPath.replace(/\/$/, "") + "/" : "https://static.img.ly/background-removal-data/1.0.3/"; let c = e; if ("string" == typeof e && (c = await fetch(e).then(e => e.blob())), c instanceof Blob && (c = await new Promise((e, t) => { const n = new FileReader; n.onload = () => e(n.result), n.onerror = t, n.readAsDataURL(c) }).then(a)), !(c instanceof ImageData)) { const e = document.createElement("canvas"); e.width = c.width, e.height = c.height; e.getContext("2d").drawImage(c, 0, 0); c = e.getContext("2d").getImageData(0, 0, c.width, c.height) } let f = null; if (t.debug, f = window.ort ? window.ort : {}, !f.InferenceSession) { const e = document.createElement("script"); e.src = n + "dist/ort-wasm-simd.min.js", document.head.appendChild(e), await new Promise(t => { e.onload = t }) } const d = await u(0, t), g = await o(0, t); if (window.SharedArrayBuffer) try { const e = { input: c, config: { inputName: "input", outputName: "output" } }; g.postMessage({ type: "run", data: e }); const t = await new Promise(e => { g.onmessage = t => { const { type: n, output: r } = t.data; "success" === type && e(r) } }); return l(t.data, c, { width: 1024, height: 1024 }).then(e => i(e, t.output?.format)) } catch (e) { console.warn("SharedArrayBuffer is not available. Falling back to main thread execution."), console.error(e) } const h = await s([128, 128, 128, 256, 256, 256], c, { width: 1024, height: 1024 }), m = new f.Tensor("float32", h, [1, 3, 1024, 1024]), p = await f.InferenceSession.create(d.original, { executionProviders: ["wasm"], graphOptimizationLevel: "all" }), w = { input: m }, v = await p.run(w), y = v.output.data; return l(y, c, { width: 1024, height: 1024 }).then(e => i(e, t.output?.format)) } }]);
//# sourceMappingURL=imgly-background-removal.min.js.map
